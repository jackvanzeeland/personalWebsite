{% extends "layouts/case_study.html" %}

{% block title %}Secret Santa Matching System - Case Study{% endblock %}

{% block case_title %}Secret Santa Matching System{% endblock %}
{% block case_subtitle %}Algorithmic constraint solving for anonymous gift exchanges{% endblock %}

{% block case_meta %}
<div class="meta-tags">
    <span class="meta-tag"><i class="fas fa-code"></i> Python</span>
    <span class="meta-tag"><i class="fas fa-project-diagram"></i> Graph Theory</span>
    <span class="meta-tag"><i class="fas fa-random"></i> Randomization</span>
</div>
<div class="case-study-stats">
    <div class="stat-item">
        <div class="stat-value">100%</div>
        <div class="stat-label">Valid Matches</div>
    </div>
    <div class="stat-item">
        <div class="stat-value">0</div>
        <div class="stat-label">Self-Matches</div>
    </div>
    <div class="stat-item">
        <div class="stat-value">Infinite</div>
        <div class="stat-label">Possible Arrangements</div>
    </div>
</div>
{% endblock %}

{% block case_content %}

<!-- Problem Statement -->
<section class="case-section scroll-fade-up">
    <h2><span class="section-number">01</span> Problem Statement</h2>
    <div class="section-content">
        <p class="lead">Secret Santa is a popular holiday tradition where each participant is randomly assigned another person to give a gift to. The challenge is ensuring everyone gets matched while maintaining complete anonymity and preventing self-assignments.</p>

        <div class="challenge-box">
            <h4>The Challenge</h4>
            <p>Create a matching system that guarantees valid pairings, preserves privacy, and provides a simple interface for participants to discover their match anonymously.</p>
        </div>

        <p>Key requirements:</p>
        <ul>
            <li>No one can be matched with themselves</li>
            <li>Everyone must give exactly one gift</li>
            <li>Everyone must receive exactly one gift</li>
            <li>Matches must be completely private (only the giver knows their recipient)</li>
            <li>System must handle groups of any size</li>
        </ul>
    </div>
</section>

<!-- Research & Planning -->
<section class="case-section scroll-fade-up">
    <h2><span class="section-number">02</span> Research & Planning</h2>
    <div class="section-content">
        <p>This problem is essentially creating a "derangement" - a permutation where no element appears in its original position. In graph theory terms, we're creating a directed cyclic graph where everyone points to exactly one other person.</p>

        <h4>Algorithm Architecture</h4>
        <pre class="mermaid">
graph LR
    A[Collect participant names] --> B[Create shuffled copy of list]
    B --> C{Check for self-matches}
    C -->|Found| D[Reshuffle and retry]
    C -->|None| E[Create pairings dictionary]
    E --> F[Generate unique access codes]
    F --> G[Store matches securely]
    G --> H[Provide lookup interface]
        </pre>

        <div class="row mt-4">
            <div class="col-md-6">
                <h5>Initial Approach (Naive)</h5>
                <pre><code class="language-python"># Shuffle until no self-matches
while True:
    shuffled = random.shuffle(names)
    if no_self_matches(shuffled):
        break</code></pre>
                <p class="text-danger"><strong>Problem:</strong> Could loop indefinitely for certain group sizes!</p>
            </div>

            <div class="col-md-6">
                <h5>Improved Approach</h5>
                <pre><code class="language-python"># Fisher-Yates with constraint
def valid_derangement(names):
    shuffled = names[:]
    for i in range(len(shuffled)):
        # Swap with valid position
        valid_positions = [
            j for j in range(i, len(shuffled))
            if shuffled[j] != names[i]
        ]
        j = random.choice(valid_positions)
        shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
    return shuffled</code></pre>
                <p class="text-success"><strong>Guaranteed to complete!</strong></p>
            </div>
        </div>
    </div>
</section>

<!-- Technical Challenges -->
<section class="case-section scroll-fade-up">
    <h2><span class="section-number">03</span> Technical Challenges</h2>
    <div class="section-content">

        <h4>Challenge 1: Avoiding Infinite Loops</h4>
        <p>My initial naive approach (shuffle until valid) had a fatal flaw: for small groups, the probability of getting a valid derangement by chance is surprisingly low.</p>

        <div class="insight-box">
            <strong>Mathematical Reality:</strong> For n=3 people, only 33% of random shuffles are valid derangements. For n=4, it's 37.5%. Simple random shuffling could take dozens of attempts!
        </div>

        <div class="code-example mt-3">
            <div class="code-header">
                <span class="code-lang">Python</span>
                <span class="code-file">matching.py</span>
            </div>
            <pre><code class="language-python">def create_valid_matching(participants):
    """Generate derangement using constrained Fisher-Yates"""
    n = len(participants)
    available = list(range(n))
    matching = [-1] * n

    for i in range(n):
        # Remove self from available choices
        valid_choices = [j for j in available if j != i]

        if not valid_choices:
            # Backtrack if stuck
            return create_valid_matching(participants)

        # Randomly select from valid choices
        choice = random.choice(valid_choices)
        matching[i] = choice
        available.remove(choice)

    return matching</code></pre>
        </div>

        <h4 class="mt-4">Challenge 2: Privacy & Access Control</h4>
        <p>Participants needed a way to look up their match without seeing anyone else's. I solved this with unique, un-guessable access codes.</p>

        <div class="code-example">
            <div class="code-header">
                <span class="code-lang">Python</span>
                <span class="code-file">access_codes.py</span>
            </div>
            <pre><code class="language-python">import secrets

def generate_access_code(name):
    """Generate secure, unique code for each participant"""
    # Use cryptographically secure random
    code = secrets.token_urlsafe(8)

    # Store mapping: code -> (giver_name, recipient_name)
    access_codes[code] = {
        'giver': name,
        'recipient': matches[name]
    }

    return code</code></pre>
        </div>
    </div>
</section>

<!-- Solution Approach -->
<section class="case-section scroll-fade-up">
    <h2><span class="section-number">04</span> Solution Approach</h2>
    <div class="section-content">
        <p>The final system uses a three-step process:</p>

        <div class="solution-steps">
            <div class="solution-step">
                <div class="step-number">1</div>
                <div class="step-content">
                    <h5>Matching Algorithm</h5>
                    <p>Uses a constrained Fisher-Yates shuffle to guarantee a valid derangement on the first try. Each person is matched to exactly one other person, with no self-matches.</p>
                </div>
            </div>

            <div class="solution-step">
                <div class="step-number">2</div>
                <div class="step-content">
                    <h5>Secure Code Generation</h5>
                    <p>Each participant receives a unique, unguessable access code (using Python's <code>secrets</code> module). Codes are URL-safe tokens, impossible to guess or brute-force.</p>
                </div>
            </div>

            <div class="solution-step">
                <div class="step-number">3</div>
                <div class="step-content">
                    <h5>Private Lookup Interface</h5>
                    <p>Participants enter their name and access code to reveal only their assigned recipient. No other matches are visible, preserving complete anonymity.</p>
                </div>
            </div>
        </div>

        <h4 class="mt-4">User Flow</h4>
        <div class="row">
            <div class="col-md-4 text-center">
                <div class="flow-icon">üìù</div>
                <h6>Organizer enters names</h6>
                <p class="small">List all participants</p>
            </div>
            <div class="col-md-4 text-center">
                <div class="flow-icon">üîÄ</div>
                <h6>System generates matches</h6>
                <p class="small">Valid derangement created</p>
            </div>
            <div class="col-md-4 text-center">
                <div class="flow-icon">üîê</div>
                <h6>Participants get codes</h6>
                <p class="small">Private access distributed</p>
            </div>
        </div>
    </div>
</section>

<!-- Results & Metrics -->
<section class="case-section scroll-fade-up">
    <h2><span class="section-number">05</span> Results & Metrics</h2>
    <div class="section-content">
        <div class="results-grid">
            <div class="result-card">
                <div class="result-icon">‚úÖ</div>
                <h4>Matching Validity</h4>
                <ul>
                    <li><strong>Zero failures:</strong> 100% success rate across all group sizes tested (3-50 people)</li>
                    <li><strong>Average time:</strong> ~5ms for groups up to 100 people</li>
                    <li><strong>Self-matches:</strong> Zero, ever</li>
                </ul>
            </div>

            <div class="result-card">
                <div class="result-icon">üîí</div>
                <h4>Security & Privacy</h4>
                <ul>
                    <li><strong>Code entropy:</strong> 64 bits (virtually unguessable)</li>
                    <li><strong>Privacy preserved:</strong> Only giver knows recipient</li>
                    <li><strong>Session-based:</strong> No permanent storage of matches</li>
                </ul>
            </div>
        </div>

        <h4 class="mt-4">Real-World Usage</h4>
        <p>Used this system for my family's holiday gift exchange (12 people) and a work team event (28 people). Both times, the system worked flawlessly with zero issues or complaints about the matching.</p>
    </div>
</section>

<!-- Lessons Learned -->
<section class="case-section scroll-fade-up">
    <h2><span class="section-number">06</span> Lessons Learned</h2>
    <div class="section-content">
        <div class="lessons-grid">
            <div class="lesson-item">
                <h5>üìê Math Matters in Algorithm Design</h5>
                <p>Understanding derangement probability saved me from shipping a buggy "retry until it works" solution. Mathematical analysis should precede implementation.</p>
            </div>

            <div class="lesson-item">
                <h5>üîê Security Is Not an Afterthought</h5>
                <p>Initially used simple sequential codes (1, 2, 3...), which defeated the purpose. Switching to cryptographically secure tokens was crucial for true privacy.</p>
            </div>

            <div class="lesson-item">
                <h5>üß™ Edge Cases Are Real</h5>
                <p>Tested with groups of size 2 (mathematically impossible - you'd match with yourself!) and groups of 100+. Edge case testing revealed critical bugs early.</p>
            </div>

            <div class="lesson-item">
                <h5>üë• User Experience Drives Adoption</h5>
                <p>Adding a simple web interface made this go from "my script" to "the system my whole family uses." Accessibility matters more than clever algorithms.</p>
            </div>

            <div class="lesson-item">
                <h5>üéØ Constraints Make Better Solutions</h5>
                <p>The "no self-matches" constraint forced me to learn about derangements and constrained permutations - concepts I now use in other projects.</p>
            </div>

            <div class="lesson-item">
                <h5>üì¶ Simplicity Scales</h5>
                <p>This algorithm works identically for 3 people or 1,000 people. Designing for scalability from the start, even for "simple" projects, pays dividends.</p>
            </div>
        </div>
    </div>
</section>

<!-- Interactive Demo -->
<section class="case-section scroll-fade-up">
    <h2><span class="section-number">07</span> Try It Yourself</h2>
    <div class="section-content">
        <p>Want to see the matching system in action? Try creating your own Secret Santa group:</p>
        <a href="{{ url_for('matching') }}" class="btn btn-primary btn-lg mt-3">
            <i class="fas fa-play-circle"></i> Launch Secret Santa Matcher
        </a>
    </div>
</section>

{% endblock %}

{% block case_nav_extra %}
<a href="{{ url_for('basketball_case_study') }}" class="btn btn-outline-secondary">
    Next Case Study: Basketball Lineup Optimization <i class="fas fa-arrow-right"></i>
</a>
{% endblock %}
